-- INDEX
CREATE INDEX EMP_INDEX ON EMP(EMPNO,ENAME);

DROP  INDEX EMP_INDEX;

/*인덱스 용도
  
*/

--DICTIONARY
SELECT * FROM DICT;
SELECT * FROM DICTIONARY
WHERE TABLE_NAME LIKE 'USER%';
/*
USER_?? : 사용자 관련 객체 정보
ALL_?? : 사용자 사용가능한 객체 정보
DBA_?? : DB관련 정보 (SYSTEM SYS)
V$_?? : VIEW 관련
*/
SELECT * FROM USER_TABLES;
SELECT * FROM ALL_TABLES WHERE OWNER='SCOTT';
SELECT * FROM USER_INDEXES;
SELECT * FROM USER_IND_COLUMNS;
SELECT * FROM OBJ;


-- VIEW



CREATE VIEW VW_EMP2
AS (SELECT E.*,D.DNAME, D.LOC
     FROM EMP E, DEPT D
     WHERE E.DEPTNO=D.DEPTNO);


SELECT * FROM USER_VIEWS;
SELECT * FROM VW_EMP2;

/* 시퀀스 (SEQUENCE)
    CREATE SEQUENCE [SEQUCENCE NAME] //무슨 이름으로 만들고
               INCREMENT BY [NUM] //얼마씩 커질건지
               START WITH [START NUM] // 몇 부터 시작하고
               NOMINVALUE OR MINVALUE [MIN NUM] 최소값
               NOMINVALUE OR MAXVALUE [MAX NUM] 최대값
               CYCLE OR NOCYCLE // CYCLE이면 값이 증가하다가 최대값에 도달하면 다시 최소값으로
               CACHE OR NOCACHE // CACHE 면 메모리 상에 임시로 저장할지 말지
*/
CREATE SEQUENCE EX_SEQ
            INCREMENT BY 1
            START WITH 1
            MINVALUE 1
            MAXVALUE 1000
            NOCYCLE
            NOCACHE;

CREATE TABLE SEQTABLE(SEQNUM NUMBER(4),TESTTXT VARCHAR2(10));
SELECT * FROM SEQTABLE;
INSERT INTO SEQTABLE VALUES(EX_SEQ.NEXTVAL,'TEST TEXT');

SELECT EX_SEQ.CURRVAL FROM DUAL;

SELECT EX_SEQ.NEXTVAL FROM DUAL; --NEXTVAL를 하면 값이 계속 증가한다.

ALTER SEQUENCE EX_SEQ INCREMENT BY 2;

/*줄번호 먹이는 방법*/
SELECT ROWNUM, A.*
FROM(
SELECT E.* 
FROM EMP E
ORDER BY ENAME
)
A
ORDER BY A.JOB;

SELECT ROW_NUMBER() OVER(ORDER BY E.JOB,E.ENAME) ROW_NUM
        ,E.*
        FROM EMP E
        ORDER BY E.JOB,E.ENAME;

SELECT ROW_NUMBER() OVER(PARTITION BY E.JOB ORDER BY E.JOB,E.ENAME) ROW_NUM
        ,E.JOB, E.ENAME
        FROM EMP E
        ORDER BY E.JOB,E.ENAME;


-- OVER(PARTITION BY)
SELECT JOB, SUM(SAL)
FROM EMP
WHERE JOB IN('MANAGER', 'SALESMAN')
GROUP BY JOB
ORDER BY JOB;

SELECT EMPNO, ENAME, DEPTNO, JOB
         ,SUM(SAL) OVER(PARTITION BY JOB, DEPTNO)
FROM EMP
WHERE JOB IN('MANAGER','SALESMAN')
ORDER BY JOB, DEPTNO;

SELECT EMPNO, ENAME, JOB, SAL
        , RANK() OVER(ORDER BY SAL DESC) 등수
        , DENSE_RANK() OVER(ORDER BY SAL DESC) AS 등수2
FROM EMP
WHERE SAL IS NOT NULL
ORDER BY SAL;

/* SYNONYM 동의어
동일한 뜻을 가지고 있는 또다른 말
 CREATE PUBLIC SYNONYM [NAME]
 FOR [TARGET]
*/
CREATE SYNONYM DE
FOR DEPT;

SELECT * FROM DE;
SELECT * FROM DEPT;

/*
Q1
*/
CREATE TABLE EMPIDX AS SELECT*FROM EMP;
-- EMPIDX 테이블의 EMPNO 값을 기준으로 한 인덱스 IDX_EMPIDX_EMPNO 생성
--
CREATE INDEX IDX_EMPIDX_EMPNO ON EMPIDX(EMPNO);



SELECT * FROM USER_INDEXES WHERE INDEX_NAME='IDX_EMPIDX_EMPNO';

-- Q2 급여가 1500을 넘는 사람의 사번 이름 직급 급여를 담은 뷰
-- EMPIDX_OVER15를 생성
DROP VIEW EMPIDX_OVER15;
CREATE OR REPLACE VIEW EMPIDX_OVER15 --CREATE 하던지 있으면 REPALCE(재정의? 덮어씌우기?)
AS(SELECT E.EMPNO, E.ENAME, E.JOB, E.SAL
FROM EMP E
WHERE E.SAL>1500);

SELECT * FROM EMPIDX_OVER15;
SELECT * FROM USER_VIEWS WHERE VIEW_NAME = 'EMPIDX_OVER15';

--Q3 
CREATE TABLE DEPTSEQ AS SELECT * FROM DEPT;
-- SEQ_DEPTSEQ 시퀀스를 생성(1에서 99까지 1씩 증가 순환없음 캐쉬안씀)
-- 

CREATE SEQUENCE SEQ_DEPTSEQ
        INCREMENT BY 1
        START WITH 1
        MAXVALUE 99
        MINVALUE 1
        NOCYCLE
        NOCACHE;

--SEQ_DEPTSEQ 시퀀스 삭제
DROP SEQUENCE SEQ_DEPTSEQ;
--SEQ_DEPTSEQ 시퀀스 생성 (10에서 100까지 60부터 10씩 증가 순환없음 캐쉬안씀)
CREATE SEQUENCE SEQ_DEPTSEQ
        INCREMENT BY 10
        START WITH 60
        MINVALUE 10
        MAXVALUE 100
        CYCLE
        NOCACHE;
INSERT INTO DEPTSEQ(DEPTNO,DNAME,LOC)
VALUES(SEQ_DEPTSEQ.NEXTVAL,'DATABASE','BUSAN');
SELECT SEQ_DEPTSEQ.CURRVAL FROM DUAL;

SELECT * FROM DEPTSEQ;

SELECT * FROM EMP WHERE DEPTNO=10
UNION
SELECT * FROM EMP WHERE DEPTNO=20
UNION
SELECT * FROM EMP WHERE DEPTNO=30;

--UNION 은 컬럼 명이 다를때는 결합이 불가능함.
SELECT DEPTNO, ENAME NAME FROM EMP WHERE DEPTNO=10
UNION
SELECT DEPTNO, DNAME NAME FROM DEPT;

-- UNION을 했을 때 겹치는 것을 보여주고 싶으면 UNION 뒤에 ALL을 붙인다.
SELECT * FROM EMP WHERE DEPTNO=20
UNION ALL
SELECT * FROM EMP WHERE DEPTNO=20;

/*  계층 구조
    START WITH [CONDITION]
    CONNECT BY PRIOR [CONDITION]
*/ 
SELECT A.EMPNO, A.ENAME, A.JOB, A.MGR, B.EMPNO, B.ENAME, B.JOB
FROM EMP A, EMP B
WHERE A.MGR=B.EMPNO;

SELECT LEVEL, EMPNO, ENAME, MGR, JOB
FROM EMP
START WITH JOB = 'PRESIDENT'
CONNECT BY PRIOR EMPNO = MGR
AND LEVEL<=2
ORDER BY LEVEL;

/*
숫자찍기
*/
SELECT * FROM (SELECT ROWNUM NUM FROM EMP E,EMP A) WHERE NUM<=24;
SELECT * FROM(SELECT 1 AS NUM FROM DUAL UNION ALL
                    SELECT 2 FROM DUAL UNION ALL
                    SELECT 3 FROM DUAL UNION ALL
                    SELECT 4 FROM DUAL UNION ALL
                    SELECT 5 FROM DUAL UNION ALL
                    SELECT 6 FROM DUAL);
                    
                    
                    
SELECT LEVEL FROM DUAL
CONNECT BY LEVEL<=24;
                    